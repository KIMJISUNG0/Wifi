<!doctype html>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Receiver - P2P Photo</title>
<style>
  body{font-family:system-ui,apple-system,Segoe UI,Roboto,Arial;margin:16px}
  button,input,textarea{font-size:16px}
  textarea{width:100%;height:120px}
  .card{border:1px solid #ddd;border-radius:12px;padding:12px;margin:12px 0}
  img{max-width:100%}
</style>

<h2>ğŸ“¥ Receiver</h2>

<div class="card">
  <p>1) Senderê°€ ë§Œë“  Offer í…ìŠ¤íŠ¸ë¥¼ ë¶™ì—¬ë„£ê³  Answer ìƒì„±</p>
  <textarea id="offerIn" placeholder="ì—¬ê¸°ì— Offer JSON ë¶™ì—¬ë„£ê¸°"></textarea>
  <button id="makeAnswer">Answer ìƒì„±</button>
</div>

<div class="card">
  <p>2) ìƒì„±ëœ Answerë¥¼ Senderì— ì „ë‹¬</p>
  <button id="copyAnswer">ğŸ“‹ Answer ë³µì‚¬</button>
  <textarea id="answerOut" readonly></textarea>
  <p id="status">ìƒíƒœ: ëŒ€ê¸°</p>
</div>

<div class="card">
  <p>3) ìˆ˜ì‹  ë¯¸ë¦¬ë³´ê¸° & ì €ì¥</p>
  <img id="preview" />
  <a id="saveLink" download style="display:none">ğŸ“¥ ë‹¤ìš´ë¡œë“œ</a>
</div>

<script>
const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
let bufs = [];
let meta = null;

pc.ondatachannel = ev => {
  const ch = ev.channel;
  ch.binaryType = 'arraybuffer';
  ch.onopen = ()=> $('status').textContent='ìƒíƒœ: ì—°ê²°ë¨';
  ch.onmessage = async evt => {
    if (typeof evt.data === 'string'){
      try{
        const msg = JSON.parse(evt.data);
        if(msg.type==='meta'){
          meta = msg; bufs=[];
          $('status').textContent=`ìˆ˜ì‹  ì¤‘: ${meta.filename} (${meta.size} bytes)`;
        } else if(msg.type==='end'){
          const blob = new Blob(bufs,{type: meta?.mime || 'application/octet-stream'});
          const url = URL.createObjectURL(blob);
          $('preview').src = url;
          const a = $('saveLink');
          a.href = url;
          a.download = meta?.filename || 'received.bin';
          a.style.display='inline-block';
          $('status').textContent='ìƒíƒœ: ìˆ˜ì‹  ì™„ë£Œ';
        }
      }catch{/* ë¬¸ìì—´ì´ì§€ë§Œ JSON ì•„ë‹˜ */}
    }else{
      bufs.push(evt.data);
    }
  };
};

function $(id){ return document.getElementById(id); }

function waitIceComplete(){
  return new Promise(res=>{
    if(pc.iceGatheringState==='complete') return res();
    const chk=()=> pc.iceGatheringState==='complete' && (pc.removeEventListener('icegatheringstatechange',chk),res());
    pc.addEventListener('icegatheringstatechange',chk);
    setTimeout(res,1500);
  });
}

$('makeAnswer').onclick = async () => {
  try{
    const offerText = ($('offerIn').value||'').trim();
    if(!offerText){ alert('Offerë¥¼ ë¶™ì—¬ë„£ì–´ ì£¼ì„¸ìš”'); return; }
    const offer = JSON.parse(offerText);
    await pc.setRemoteDescription(offer);
    await pc.setLocalDescription(await pc.createAnswer());
    await waitIceComplete();
    $('answerOut').value = JSON.stringify(pc.localDescription);
    $('status').textContent='ìƒíƒœ: Answer ìƒì„±ë¨ (Senderì— ë¶™ì—¬ë„£ê¸°)';
  }catch(e){ alert('Answer ìƒì„± ì˜¤ë¥˜: '+e); }
};

$('copyAnswer').onclick = () => {
  const text = $('answerOut').value;
  if (!text) { alert('ë³µì‚¬í•  Answerê°€ ì—†ìŠµë‹ˆë‹¤'); return; }
  navigator.clipboard.writeText(text)
    .then(()=>alert('Answerê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!'))
    .catch(err=>alert('ë³µì‚¬ ì‹¤íŒ¨: ' + err));
};
</script>
