<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>P2P Manual • Sender</title>
<style>
  :root{
    --bg:#0b1220; --card:#111a2b; --ink:#e8f0ff; --sub:#9bb3d3; --pri:#5ee7c1; --acc:#6ea8fe; --warn:#ffb86b;
  }
  *{box-sizing:border-box} body{margin:0;background:radial-gradient(1200px 600px at 20% -10%,#1b2a4b22,transparent),var(--bg);color:var(--ink);font:16px/1.5 ui-sans-serif,system-ui,Segoe UI,Apple SD Gothic Neo,Malgun Gothic}
  .wrap{min-height:100dvh;display:grid;place-items:center;padding:24px}
  .card{width:min(840px,92vw);background:linear-gradient(180deg,#111a2b,#0f1829);border:1px solid #21304a;border-radius:18px;box-shadow:0 10px 30px #0007;padding:22px 22px 14px}
  h1{margin:4px 0 14px;font-size:28px;letter-spacing:.2px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .pill{padding:6px 10px;border-radius:999px;background:#15233b;color:var(--sub);border:1px solid #243552;font-size:13px}
  .green{color:var(--pri)} .amber{color:var(--warn)} .blue{color:var(--acc)}
  .grid{display:grid;gap:14px;margin-top:12px}
  .two{grid-template-columns:1fr 1fr}
  label{font-size:13px;color:var(--sub)}
  input[type=text], textarea{width:100%;background:#0d1629;border:1px solid #203252;color:var(--ink);border-radius:10px;padding:10px 12px;outline:none}
  textarea{min-height:140px;resize:vertical}
  .btn{appearance:none;border:1px solid #2a3f65;background:#15233b;color:#e6f2ff;border-radius:10px;padding:10px 14px;cursor:pointer;font-weight:600}
  .btn:hover{background:#1b2a45}
  .btn.pri{background:linear-gradient(180deg,#3dd6ae,#23c09b);border-color:#23c09b;color:#07261e}
  .btn.ghost{background:transparent}
  .muted{color:var(--sub);font-size:13px}
  .chat{height:180px;overflow:auto;background:#0b1426;border:1px dashed #25395d;border-radius:10px;padding:10px}
  .row > .btn{white-space:nowrap}
  .center{display:flex;justify-content:center;gap:10px;flex-wrap:wrap}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#0f1a2d;border:1px solid #273a60;color:var(--sub);font-size:13px}
  .ok{color:var(--pri)} .wait{color:var(--warn)} .err{color:#ff7b7b}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>⚡ Aurora Beam <span class="pill">Sender</span></h1>

    <div class="row">
      <div class="badge">상태: <span id="state" class="wait">대기</span></div>
      <div class="badge">ICE: <span id="ice" class="wait">-</span></div>
      <div class="badge">DC: <span id="dc" class="wait">-</span></div>
    </div>

    <div class="grid two" style="margin-top:10px">
      <div>
        <label>🔐 암호화 키 (양쪽 동일해야 함)</label>
        <div class="row">
          <input id="key" type="text" placeholder="없으면 생성 버튼을 누르세요" />
          <button class="btn" id="btnGen">키 생성</button>
          <button class="btn" id="btnCopyKey">복사</button>
        </div>
        <div class="muted">AES-256-GCM. 키는 공유한 사람과 직접 교환하세요(페이지는 저장하지 않음).</div>
      </div>

      <div>
        <label>📁 파일 선택 (선택사항)</label>
        <div class="row">
          <input id="file" type="file" accept="image/*" multiple />
          <button class="btn" id="btnSendFile">파일 전송</button>
        </div>
        <div class="muted">여러 장 선택 가능. 크기가 큰 경우 전송에 시간이 걸릴 수 있습니다.</div>
      </div>
    </div>

    <hr style="border:none;border-top:1px solid #263a5e;margin:16px 0">

    <div class="grid two">
      <div>
        <label>1) Offer 생성 → 아래 JSON을 복사해 Receiver에 전달</label>
        <div class="row">
          <button class="btn pri" id="btnOffer">Offer 만들기</button>
          <button class="btn" id="copyOffer">복사</button>
        </div>
        <textarea id="offerOut" readonly placeholder="여기에 Offer JSON이 생성됩니다"></textarea>
      </div>

      <div>
        <label>2) Receiver의 Answer JSON을 붙여넣고 적용</label>
        <div class="row">
          <button class="btn" id="btnApplyAnswer">Answer 적용</button>
          <button class="btn ghost" id="clearAns">비우기</button>
        </div>
        <textarea id="answerIn" placeholder="여기에 Answer JSON 붙여넣기"></textarea>
      </div>
    </div>

    <hr style="border:none;border-top:1px solid #263a5e;margin:16px 0">

    <div class="grid two">
      <div>
        <label>💬 채팅</label>
        <div class="row">
          <input id="msg" type="text" placeholder="메시지 입력" />
          <button class="btn" id="send">Send</button>
        </div>
        <div id="log" class="chat" aria-live="polite"></div>
      </div>

      <div>
        <label>📥 수신 파일</label>
        <div id="files" class="chat"></div>
      </div>
    </div>

    <div class="center" style="margin-top:10px">
      <span class="muted">수신자가 Answer를 적용해야 연결이 완료됩니다.</span>
    </div>
  </div>
</div>

<script>
  // --- UI helpers ---
  const $ = s => document.querySelector(s);
  const stateEl = $('#state'), iceEl = $('#ice'), dcEl = $('#dc');
  const logEl = $('#log'), filesEl = $('#files');

  function log(txt){ const p=document.createElement('div'); p.textContent=txt; logEl.appendChild(p); logEl.scrollTop=logEl.scrollHeight; }
  function fileLink(name, blob){
    const a=document.createElement('a'); a.textContent=`⬇ ${name} (${Math.round(blob.size/1024)} KB)`;
    a.href=URL.createObjectURL(blob); a.download=name; a.style.display='block';
    filesEl.appendChild(a); filesEl.scrollTop=filesEl.scrollHeight;
  }
  async function copy(text){
    try{ await navigator.clipboard.writeText(text); }catch(e){ console.warn(e); }
  }
  function genKeyBase64(){
    const raw=new Uint8Array(32); crypto.getRandomValues(raw);
    return btoa(String.fromCharCode(...raw));
  }
  async function importKey(b64){
    const raw=Uint8Array.from(atob(b64),c=>c.charCodeAt(0));
    return crypto.subtle.importKey("raw", raw, "AES-GCM", false, ["encrypt","decrypt"]);
  }
  async function encrypt(key, data){
    const iv=crypto.getRandomValues(new Uint8Array(12));
    const buf=typeof data==="string" ? new TextEncoder().encode(data) : data;
    const ct=await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, buf);
    return { iv:Array.from(iv), ct:Array.from(new Uint8Array(ct)) };
  }
  async function decrypt(key, packet){
    const iv=new Uint8Array(packet.iv); const ct=new Uint8Array(packet.ct);
    const pt=await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct);
    return new Uint8Array(pt);
  }

  // --- WebRTC basics (manual exchange) ---
  const pc = new RTCPeerConnection({ iceServers:[{urls:"stun:stun.l.google.com:19302"}] });
  let dc, cryptoKey;
  $('#btnGen').onclick = ()=> $('#key').value = genKeyBase64();
  $('#btnCopyKey').onclick = ()=> copy($('#key').value);

  pc.oniceconnectionstatechange = ()=> { stateEl.textContent = pc.iceConnectionState; stateEl.className = pc.iceConnectionState==="connected"?"ok":"wait"; };
  pc.onicegatheringstatechange = ()=> { iceEl.textContent = pc.iceGatheringState; };
  pc.onconnectionstatechange = ()=> { /* overall */ };
  pc.ondatachannel = (ev)=>{
    dc = ev.channel;
    attachDC();
  };

  function attachDC(){
    dcEl.textContent = dc.readyState; dcEl.className = (dc.readyState==="open")?"ok":"wait";
    dc.onopen = ()=>{ dcEl.textContent = "open"; dcEl.className="ok"; log("✅ DataChannel opened"); };
    dc.onclose= ()=>{ dcEl.textContent = "closed"; dcEl.className="err"; log("❌ DataChannel closed"); };
    dc.onmessage = async (ev)=>{
      if(!cryptoKey){ log("⚠ 암호키 없음: 수신 불가"); return; }
      const packet = JSON.parse(ev.data);
      const plain = await decrypt(cryptoKey, packet);
      // 첫 바이트가 0x01 이면 파일-메타, 0x02 이면 파일-데이터, 아니면 텍스트
      if(plain[0]===1){
        // 메타: [1][nameLen][...nameUTF8]
        const nameLen = plain[1];
        const name = new TextDecoder().decode(plain.slice(2,2+nameLen));
        window._recvFile = { name, chunks:[] };
        log(`📦 파일 수신 시작: ${name}`);
      }else if(plain[0]===2){
        window._recvFile?.chunks.push(plain.slice(1));
      }else if(plain[0]===3){
        const blob = new Blob(window._recvFile.chunks, {type:"application/octet-stream"});
        fileLink(window._recvFile.name, blob);
        window._recvFile = null;
        log(`✅ 파일 수신 완료`);
      }else{
        const text = new TextDecoder().decode(plain);
        log("📩 " + text);
      }
    };
  }

  async function ensureKey(){
    const b64 = $('#key').value.trim();
    if(!b64){ alert("암호화 키를 먼저 생성/입력하세요."); throw new Error("no-key"); }
    cryptoKey = await importKey(b64);
  }

  // Offer 만들기
  $('#btnOffer').onclick = async ()=>{
    await ensureKey();
    dc = pc.createDataChannel("data");
    attachDC();
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    // ICE 모으기 완료까지 대기
    await new Promise(res=>{
      if(pc.iceGatheringState==='complete') return res();
      pc.onicegatheringstatechange=()=> pc.iceGatheringState==='complete' && res();
    });
    $('#offerOut').value = JSON.stringify(pc.localDescription);
  };
  $('#copyOffer').onclick = ()=> copy($('#offerOut').value);

  // Answer 적용
  $('#btnApplyAnswer').onclick = async ()=>{
    const txt = $('#answerIn').value.trim();
    if(!txt) return alert("Answer JSON을 붙여넣으세요.");
    const desc = JSON.parse(txt);
    await pc.setRemoteDescription(desc);
    log("🔗 원격 Answer 적용됨");
  };
  $('#clearAns').onclick = ()=> $('#answerIn').value='';

  // 채팅 전송
  $('#send').onclick = async ()=>{
    if(!dc || dc.readyState!=="open") return alert("연결이 아직 열리지 않았습니다.");
    await ensureKey();
    const text = $('#msg').value.trim(); if(!text) return;
    const plain = new TextEncoder().encode(text);
    const packet = await encrypt(cryptoKey, plain);
    dc.send(JSON.stringify(packet));
    log("➡ " + text);
    $('#msg').value="";
  };

  // 파일 전송(간단 버전: 메타 → 데이터 → 종료)
  $('#btnSendFile').onclick = async ()=>{
    if(!dc || dc.readyState!=="open") return alert("연결이 아직 열리지 않았습니다.");
    await ensureKey();
    const files = $('#file').files;
    if(!files || !files.length) return alert("파일을 선택하세요.");
    for(const f of files){
      // 1) 메타
      const nameBytes = new TextEncoder().encode(f.name);
      const meta = new Uint8Array(2 + nameBytes.length);
      meta[0]=1; meta[1]=nameBytes.length; meta.set(nameBytes,2);
      dc.send(JSON.stringify(await encrypt(cryptoKey, meta)));

      // 2) 데이터 (그냥 통째로 – 큰 파일은 추후 chunk로 개선)
      const buf = new Uint8Array(await f.arrayBuffer());
      const data = new Uint8Array(1+buf.length); data[0]=2; data.set(buf,1);
      dc.send(JSON.stringify(await encrypt(cryptoKey, data)));

      // 3) 종료 신호
      const fin = new Uint8Array([3]);
      dc.send(JSON.stringify(await encrypt(cryptoKey, fin)));

      log(`🚀 전송: ${f.name}`);
    }
  };
</script>
</body>
</html>
