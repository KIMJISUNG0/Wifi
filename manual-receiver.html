<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>P2P Manual • Receiver</title>
<style>
  :root{
    --bg:#0b1220; --card:#111a2b; --ink:#e8f0ff; --sub:#9bb3d3; --pri:#5ee7c1; --acc:#6ea8fe; --warn:#ffb86b;
  }
  *{box-sizing:border-box} body{margin:0;background:radial-gradient(1200px 600px at 80% -10%,#1b2a4b22,transparent),var(--bg);color:var(--ink);font:16px/1.5 ui-sans-serif,system-ui,Segoe UI,Apple SD Gothic Neo,Malgun Gothic}
  .wrap{min-height:100dvh;display:grid;place-items:center;padding:24px}
  .card{width:min(840px,92vw);background:linear-gradient(180deg,#111a2b,#0f1829);border:1px solid #21304a;border-radius:18px;box-shadow:0 10px 30px #0007;padding:22px 22px 14px}
  h1{margin:4px 0 14px;font-size:28px;letter-spacing:.2px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .pill{padding:6px 10px;border-radius:999px;background:#15233b;color:var(--sub);border:1px solid #243552;font-size:13px}
  .grid{display:grid;gap:14px;margin-top:12px}
  .two{grid-template-columns:1fr 1fr}
  label{font-size:13px;color:var(--sub)}
  input[type=text], textarea{width:100%;background:#0d1629;border:1px solid #203252;color:var(--ink);border-radius:10px;padding:10px 12px;outline:none}
  textarea{min-height:140px;resize:vertical}
  .btn{appearance:none;border:1px solid #2a3f65;background:#15233b;color:#e6f2ff;border-radius:10px;padding:10px 14px;cursor:pointer;font-weight:600}
  .btn:hover{background:#1b2a45}
  .btn.pri{background:linear-gradient(180deg,#3dd6ae,#23c09b);border-color:#23c09b;color:#07261e}
  .btn.ghost{background:transparent}
  .muted{color:var(--sub);font-size:13px}
  .chat{height:180px;overflow:auto;background:#0b1426;border:1px dashed #25395d;border-radius:10px;padding:10px}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#0f1a2d;border:1px solid #273a60;color:var(--sub);font-size:13px}
  .ok{color:var(--pri)} .wait{color:var(--warn)} .err{color:#ff7b7b}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>⚡ Aurora Beam <span class="pill">Receiver</span></h1>

    <div class="row">
      <div class="badge">상태: <span id="state" class="wait">대기</span></div>
      <div class="badge">ICE: <span id="ice" class="wait">-</span></div>
      <div class="badge">DC: <span id="dc" class="wait">-</span></div>
    </div>

    <div class="grid two" style="margin-top:10px">
      <div>
        <label>🔐 암호화 키 (양쪽 동일해야 함)</label>
        <div class="row">
          <input id="key" type="text" placeholder="발신자와 같은 키를 입력/붙여넣기" />
          <button class="btn" id="btnGen">키 생성</button>
          <button class="btn" id="btnCopyKey">복사</button>
        </div>
        <div class="muted">AES-256-GCM. 키는 직접(오프라인/메신저 등) 공유하세요.</div>
      </div>

      <div>
        <label>📁 선택 사항: 내 파일도 보내보기 (연결 후)</label>
        <div class="row">
          <input id="file" type="file" accept="image/*" multiple />
          <button class="btn" id="btnSendFile">파일 전송</button>
        </div>
      </div>
    </div>

    <hr style="border:none;border-top:1px solid #263a5e;margin:16px 0">

    <div class="grid two">
      <div>
        <label>1) Sender의 Offer JSON을 붙여넣고 Answer 생성</label>
        <div class="row">
          <button class="btn pri" id="btnAnswer">Answer 만들기</button>
          <button class="btn" id="copyAnswer">복사</button>
        </div>
        <textarea id="offerIn" placeholder="여기에 Sender Offer JSON 붙여넣기"></textarea>
      </div>

      <div>
        <label>2) 생성된 Answer JSON을 Sender에 전달</label>
        <textarea id="answerOut" readonly placeholder="여기에 Answer JSON이 생성됩니다"></textarea>
      </div>
    </div>

    <hr style="border:none;border-top:1px solid #263a5e;margin:16px 0">

    <div class="grid two">
      <div>
        <label>💬 채팅</label>
        <div class="row">
          <input id="msg" type="text" placeholder="메시지 입력" />
          <button class="btn" id="send">Send</button>
        </div>
        <div id="log" class="chat" aria-live="polite"></div>
      </div>

      <div>
        <label>📥 수신 파일</label>
        <div id="files" class="chat"></div>
      </div>
    </div>

    <div class="muted" style="margin-top:10px">연결이 열리면 DC: open 으로 표시됩니다.</div>
  </div>
</div>

<script>
  const $ = s => document.querySelector(s);
  const stateEl=$('#state'), iceEl=$('#ice'), dcEl=$('#dc'), logEl=$('#log'), filesEl=$('#files');
  function log(t){const d=document.createElement('div'); d.textContent=t; logEl.appendChild(d); logEl.scrollTop=logEl.scrollHeight;}
  function fileLink(name, blob){
    const a=document.createElement('a'); a.textContent=`⬇ ${name} (${Math.round(blob.size/1024)} KB)`;
    a.href=URL.createObjectURL(blob); a.download=name; a.style.display='block';
    filesEl.appendChild(a); filesEl.scrollTop=filesEl.scrollHeight;
  }
  async function copy(txt){ try{await navigator.clipboard.writeText(txt);}catch(e){} }
  function genKeyBase64(){ const raw=new Uint8Array(32); crypto.getRandomValues(raw); return btoa(String.fromCharCode(...raw)); }
  async function importKey(b64){ const raw=Uint8Array.from(atob(b64),c=>c.charCodeAt(0)); return crypto.subtle.importKey("raw",raw,"AES-GCM",false,["encrypt","decrypt"]); }
  async function encrypt(key,data){const iv=crypto.getRandomValues(new Uint8Array(12)); const buf=typeof data==="string"?new TextEncoder().encode(data):data; const ct=await crypto.subtle.encrypt({name:"AES-GCM",iv},key,buf); return {iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))};}
  async function decrypt(key,packet){const iv=new Uint8Array(packet.iv); const ct=new Uint8Array(packet.ct); const pt=await crypto.subtle.decrypt({name:"AES-GCM",iv},key,ct); return new Uint8Array(pt);}

  const pc = new RTCPeerConnection({ iceServers:[{urls:"stun:stun.l.google.com:19302"}] });
  let dc, cryptoKey;
  $('#btnGen').onclick=()=> $('#key').value=genKeyBase64();
  $('#btnCopyKey').onclick=()=> copy($('#key').value);

  pc.oniceconnectionstatechange=()=>{stateEl.textContent=pc.iceConnectionState; stateEl.className=pc.iceConnectionState==="connected"?"ok":"wait";};
  pc.onicegatheringstatechange=()=>{iceEl.textContent=pc.iceGatheringState;};
  pc.ondatachannel=(ev)=>{ dc=ev.channel; attachDC(); };

  function attachDC(){
    dcEl.textContent=dc.readyState; dcEl.className=(dc.readyState==="open")?"ok":"wait";
    dc.onopen=()=>{dcEl.textContent="open"; dcEl.className="ok"; log("✅ DataChannel opened");};
    dc.onclose=()=>{dcEl.textContent="closed"; dcEl.className="err"; log("❌ DataChannel closed");};
    dc.onmessage= async (ev)=>{
      if(!cryptoKey){ log("⚠ 암호키 없음: 수신 불가"); return; }
      const packet=JSON.parse(ev.data);
      const plain=await decrypt(cryptoKey, packet);
      if(plain[0]===1){
        const nameLen=plain[1]; const name=new TextDecoder().decode(plain.slice(2,2+nameLen));
        window._recvFile={name, chunks:[]}; log(`📦 파일 수신 시작: ${name}`);
      }else if(plain[0]===2){
        window._recvFile?.chunks.push(plain.slice(1));
      }else if(plain[0]===3){
        const blob=new Blob(window._recvFile.chunks,{type:"application/octet-stream"});
        fileLink(window._recvFile.name, blob); window._recvFile=null; log(`✅ 파일 수신 완료`);
      }else{
        const text=new TextDecoder().decode(plain); log("📩 "+text);
      }
    };
  }

  async function ensureKey(){
    const b64=$('#key').value.trim();
    if(!b64){ alert("암호화 키를 먼저 입력/생성하세요."); throw new Error("no-key"); }
    cryptoKey = await importKey(b64);
  }

  // Answer 만들기 (Offer 붙여넣기 후)
  $('#btnAnswer').onclick = async ()=>{
    await ensureKey();
    const txt=$('#offerIn').value.trim();
    if(!txt) return alert("Offer JSON을 붙여넣으세요.");
    await pc.setRemoteDescription(JSON.parse(txt));
    const answer=await pc.createAnswer();
    await pc.setLocalDescription(answer);
    // ICE 모으기 완료까지 대기
    await new Promise(res=>{
      if(pc.iceGatheringState==='complete') return res();
      pc.onicegatheringstatechange=()=> pc.iceGatheringState==='complete' && res();
    });
    $('#answerOut').value = JSON.stringify(pc.localDescription);
    log("🔗 Answer 생성 완료 – Sender에 전달하세요.");
  };
  $('#copyAnswer').onclick = ()=> copy($('#answerOut').value);

  // 채팅
  $('#send').onclick = async ()=>{
    if(!dc || dc.readyState!=="open") return alert("연결이 아직 열리지 않았습니다.");
    await ensureKey();
    const text=$('#msg').value.trim(); if(!text) return;
    const plain=new TextEncoder().encode(text);
    const packet=await encrypt(cryptoKey, plain);
    dc.send(JSON.stringify(packet));
    log("➡ " + text);
    $('#msg').value="";
  };

  // 파일 전송(옵션)
  $('#btnSendFile').onclick = async ()=>{
    if(!dc || dc.readyState!=="open") return alert("연결이 아직 열리지 않았습니다.");
    await ensureKey();
    const files=$('#file').files; if(!files||!files.length) return alert("파일을 선택하세요.");
    for(const f of files){
      const nameBytes=new TextEncoder().encode(f.name);
      const meta=new Uint8Array(2+nameBytes.length); meta[0]=1; meta[1]=nameBytes.length; meta.set(nameBytes,2);
      dc.send(JSON.stringify(await encrypt(cryptoKey, meta)));
      const buf=new Uint8Array(await f.arrayBuffer()); const data=new Uint8Array(1+buf.length); data[0]=2; data.set(buf,1);
      dc.send(JSON.stringify(await encrypt(cryptoKey, data)));
      const fin=new Uint8Array([3]); dc.send(JSON.stringify(await encrypt(cryptoKey, fin)));
      log(`🚀 전송: ${f.name}`);
    }
  };
</script>
</body>
</html>
